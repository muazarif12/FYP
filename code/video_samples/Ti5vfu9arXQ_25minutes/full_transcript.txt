 Hi, I'm Ocus, a technical recruiter here at Google. In this video, we'll show two software engineers at Google working through a mock technical interview question. Please note that this example is not a question you'll be asked exactly. However, it represents the type of questions we like to ask our candidates, one that allows you to state your assumptions, improve your solution, and is ultimately open-handed enough to show us how you think. If you're interested in seeing an example of solving a systems design question or learning more about our hiring process, visit the videos linked in the description below. On to the mock interview. Hello, my name is Sami. I'm a research scientist at Google Research. And today, I'll be playing the role of the candidate. And I'm Juliana. I'm a software engineer at YouTube. And I'll be playing the role of the interviewer. Just as a reminder, you won't have access to a compiler or IDE during your interview. So practice writing code with Google Docs. Try to do it at home. Write code. Make sure your code is tested. Do this process before you come to the interview. And don't worry about small syntax errors, like which substring to use for a given method. Just pick one, like start, end, or start length, and let your interviewer know. OK? Let's get started. OK. So Sami, here's my technical question for you. A farmer wants to farm their land with the maximum area where good land is present. The land is represented as a matrix with ones and zeros, where ones mean good land and zeros mean bad land. The farmer only wants to farm in a square of good land with the maximum area. Please help the farmer to find a maximum area of the land they can farm in good land. I'll paste the question, and that includes an example as well for you. Awesome. May I take a moment to read it and then ask you clarifications? Of course. Thank you. Awesome. So my first question, must it be a square, the area they want to farm, or could it be a rectangle? For this problem, we only want it to be returning a square. Awesome. OK, thank you. As a reminder, it's important to get clarity whenever possible. Many questions will be deliberately open-ended because we're looking to see how you engage with a problem and your primary method for solving it. Be sure to talk through your thought process and feel free to ask specific questions if you need clarification. And I can think of like the naive solution, but probably I shouldn't do this, but I'll just run it by you. OK. I can loop over every position. And for every position, I can basically start from that moment onwards, go left and right, and count however many ones I can find in like a rectangle or a square, sorry. But that would be, if let's say the dimensions of the square is like n by n, that would be at best n to the 4, which is not ideal. And I assume by posing this question, you want to find an efficient solution. Yes. This was a good example of explaining your thoughts. Remember, we want to understand how you think, so it's always good to explain your thought process and decision-making throughout the interview. We're not only evaluating your technical ability, but also how to solve your problems. Be sure to explicitly state and check your assumptions with the interviewer to ensure they are reasonable. I'm wondering if you can just visualize what maybe this brute force approach would look like, maybe using the example. Sure. OK. So the brute force, if I want to visualize it, so I just pasted the example. And I'm going to go over every index, IJ index. And I held it the first, this is the second, this is the third, et cetera. Let's say we get here in this iteration. So I is becoming, let's say, two and J is becoming one in this position, the row and column. So from this point, as every point that we go to, we start another double for loop, going to the right and bottom. So here I go one step to the right, there is a one, so I continue. And then I go to the bottom, there is a one and I continue. And then I go to the right of it, there's a one, I continue. I wonder if that makes sense. So first we start saying, OK, when we get to this point, we know that we can do a one by one. Then we ask, can we do a two by two? And if the answer, to answer that, we have to complete the two by two triangle. So we have to look in this vicinity, so to speak. Yes. Then we say, OK, now, yes, I know I can do a two by two starting from this position. Can I do a three by three? And to answer that, we have to go on this like wrapper, like I'm going to select them one by one, because it's harsh like otherwise. And then I select those. So we extend the boundary by one column and one row to check that they're all ones there. And then we keep track of the maximum. So if we arrived at three here, then I memorized that three is the best so far. And until I loop over all the indices possible, maybe I'll update my three to something else. And then I'll return wherever number has been kept. But as we already said, this is not optimal, but it will do the job. I think that even though this may be a brute force solution, it would be the right approach in checking the nearby values and having that inform how large the square could be. Awesome. And I guess, do you want to program this brute force solution? Or am I going to penalize it? Should I just think about something better? We can just move on to maybe what you would consider a more optimal solution. Sure. Awesome. Okay. So these kinds of problems, I feel like I can solve them in two other different ways. The first one would be recursive. So here, the recursion can say, let's ignore the zeros, because as soon as I find a zero, we can just return from this point, you can't have a square. But let's say we get to this point, it's like, oh, yes, there's a one, so I can make a one by one. And then we can ask the surroundings, can we make more than one by one? And then if I can ask the square next to me, actually, let me think about it. Okay. If this is a one, the right of it is a one, the bottom of it is a one, we can ask this, that I'm highlighting, how big of a square can you make it? Actually. No, I think you're on the right track, that you're checking the right below and diagonal values. But because there is a zero here, does that mean it could be a valid square? Zero is invalid, right? Yes, yes. That would be the case. So based on that, what can you infer that if you're at that one position, at that index? Yeah. That index. What can you infer as the maximum square? At this index, it is a one because we can see the diagonal is already a zero. Yes, yes, that's correct. But you then know that the neighboring values are also ones, so there is a possibility that those could have valid squares that are greater than one. Correct, yes. I mean, in this specific case, because the diagonal is zero, that means this next to this one below it is a zero. Unless we're coming from above. That's true. Right. I guess the one below it, actually neither of those. But you could potentially have, as you're saying, a recursive algorithm. How would that look then? Mm-hmm. So the recursive algorithm, I'm trying to think out loud as I'm describing the solution. So basically, when we see a one here, we can ask, can this be part of a bigger rectangle? And recursively, how would that look like? We have to ask the neighbors how many ones they have consecutively, contiguously. Mm-hmm. So that could be saying that, okay, there's a one here. And then we can invoke a recursive call that says, how many ones are starting at the right of me making a square? So if I wish I can highlight, but let's imagine me, I'm going to bold this, I'm going to bold this, that marks the end and the beginning of a square. Mm-hmm. So when I ask this one, how many ones do you have, how big of a square can you form? It could ask the one right of it, how many can you form? It can ask the bottom of it, how many can you form? Yes. And then if, how, whichever, so whichever returns the minimum, I will take that and I'll add one to it. Trying to think if this will always be correct. Correct. So if this one said, I can do a two by two, let's say it's, it clearly can do a two by two. I'm going to change your input by a little bit if that's okay. So which, which means this would have been one, this would have been a one. Okay. And this, the one that I'm highlighting is asking the one right of it, how big can you, can you be, your square could be. This will say, oh, I can do a two. Then it asks the bottom of it, how big of a square can you do? In this particular case is going to say three. Three. Because I can see the ones like here, this one. I think that. And this one are making a square. Ah, I see. So you would compute it like top down. So that one that you've highlighted in the, in two, two index or two, two coordinates would have it contain a three value because it can form that three by three square. Right. Exactly. Got it. Yes. That makes sense. And let me see if, if taking the minimum is sufficient, so to speak. So this one can create a three by three. Yes. The one right of it can create a two by two. Or I guess now the example is so corrupted because I kept changing things. Let's see. Actually, this one. Yes. So this one that maybe I should color. So let me color this to red. The red one will say I can do a two by two starting from this coordinate. Yes. The, the blue one or the one that will become blue will say I can do a three by three starting at this coordinate. Yep. Now, how much can this one create the one I'm highlighting? It would still be the minimum. Yes. I'm thinking, right? Because you can do more than three by three. Okay. So now, now we can think about the base cases of the recursion, so to speak. Yes. So the base case, if we had a zero, then we can't do, we return a zero. Yes. If we had a one, then we ask the right and the bottom to do the recursion. We invoke them. Yes. And we return their minimum. Yes. I'm trying to think at which case do we, in which case do we grow? I'm thinking we can grow. Let me think. So if this, if the right one hypothetically said I could do a three by three, I'm just thinking. And, and the bottom one can say I can do a three by three. Okay. Um, I, I need to think that there, there, there has to be that we can grow the ones, you know, we have to return a five or something eventually. So if the right of me can say I can do a three by three, which, you know, so maybe I can hack the numbers again, just for the sake of example, it can say I can do a three by three. Uh, actually this is a, still a two by two. Okay. I have to do this as a one. So the red, the red one can now do a three by three. The blue one can also do three by three. Only three by three. Exactly. Um, then this one is so far as going to say three is the number. Yes. However, if this was a one right here. It would be four. Then it will be four. But let me just like. So that would mean the diagonal number would also be three. To which case, because you have a one in that first field, the, at the zero one coordinates, um, what could that say? If all of the three values down diagonal and to your right are all three and this is a one, what could that be? Makes sense. Okay. So if all the values are three, then I should say I can do four. Exactly. Yes. Okay. Okay. So I think, I think I'm able to write it recursively. Of course, the recursion is not the most optimal because it has to retry something multiple times. Yes. We can always add a memorization memory element to it. This way, you, each unique invocation will only happens only once. Yeah. Which will make this be at most quadratic. We can, we will invoke at most n square times. And, but usually for anything that you can do with memorization, there ought to be a dynamic programming solution where you can do bottoms up. That's correct. You want me to program the recursive memorization lazy version, or should I strive for the most efficient dynamic programming version? I'm thinking that I want to first see your thinking for the bottom up, the dynamic programming solution, and then we can go ahead and code it. I just want to see what your thinking would be for how bottom up would look. Sure. Okay. You kind of gave me a hint already by saying, check the diagonal, if it also can do a three by three. So in that regard, maybe I can have, I can, this is the input we're highlighting right now. We can start with the, with the dynamic programming array with this, that has the same exact size, but it's initialized to zero everywhere. Yeah. Then at any moment that I want to compute an entry, I want to populate an entry in this DP matrix that starts at all zeros. I'll be looking at the same position of the input and also the surrounding positions of the input and potentially the surrounding positions of the dynamic programming array, the DP array, and populate it incrementally as such. And so your DP array would contain which, what values exactly? Okay. So at every, at every entry in the input, if the entry in the input is zero, then we should write zero in the dynamic programming array. If the entry is one, then we need to basically look at the surrounding positions, as you said, like the top position, just top of me, just left of me, just diagonal left of me in the dynamic programming array. And we should take the minimum, but if they all agree to be like the same value, I'll just increment by one in the DP array. And the final return of this whole program is the maximum entry in the DP array. Yeah. Does that sound correct? That sounds correct. I do want to highlight that you will be then capturing the height of the square instead of the area in this array. Mm-hmm. Even that's fine too, if that's the direction you want to go in. Capturing the height. Okay. Because it is a square, so. It is a square, I see. Yeah. That's right. Yes. Okay. Should I start programming the dynamic solution and I can explain it as I program it, if that's okay? That sounds great. Let's do it. Okay. So programming Python into a document. So maybe I can choose Consolus as a font and I can say def largest square and it takes input as a binary array. I'm going to say bin array. Is that fine? Do you want it to be typed or no typed? As in like, you know, the typing of Python. Should I do something like this? MP.nd array or at least say it's a list of list of int. Yeah. Do you want these types? It will be a list of, it will be a 2D array of ints. Yeah. That's perfect. Awesome. So, and then the answer is just an int, which is the maximum area. Exactly. Okay. So first I'm going to say my DP array is equal to an array of all zeros. I guess I can, I want to capture first n, which is just the length of the bin array. So it could be a 5 by 5, 10 by 10 square, et cetera. That's n by n. So we want to make an all zero. I'm going to do this. Okay. So now after this line DP is just an n by n array with all zeros. Oh, something that I wanted to point out here is that it's possible that it's a n by n. The width and the height do not agree. May not agree. Yes. For the input array. Good to know. But your output array or your output area should be a square. Thank you for making this clarification. Okay. So then I will do this as my n times m. Okay. And now I can say something like this. Yep. So let me just make sure, yes, I'm consistent in my indexing, so to speak. That if an index ij exists in DP, then it must also exist in bin array. Yep. Awesome. Okay. So my DP starts at all zero. Now we're going to do the double for loop that we mentioned. So for i in range n. Mm-hmm. For j in range m. And here at every square, we're going to write the maximum that we can do. Yes. Scroll down. So let me think. First, if the entry had a zero. Yeah. If bin array of i j is zero, then the DP will have a zero in it. Yeah. So in that case, I will just, because the DP was initialized at zero, I can just continue. I can skip to the next iteration if I'm allowed to use continue. Yeah. Yeah. Of course. Okay. So then at any entry that's not a zero, we should look up the left and the top and the diagonal, and we'll see their values. So maybe I can say left value is equal to right value for now. I'll set them later to the diagonal value all to zero, and I'll set them conditionally. Why? Because I don't want to skip the boundary conditions. So if the left of me, if i is greater than zero, that means I'm not at the boundary. That means the left could be something that's not zero. So now we set the left to DP of i minus one j. Yep. And I want to do the same thing, similar thing to the right one. Otherwise they will stay at zero. Quick question. Yes. Is it possible to handle the boundaries before you enter this scope? Yes. Yes, I'm sure. So we could copy the boundaries from the input verbatim to the DP, and then our loop could be starting from one instead of from zeros. I'm thinking more so that if you are in the zeroth index of the row or the column, if there's a handling you could do before you enter this scope of setting the left and right diagonal indices. So you're saying like before we enter these loops, we should handle the borders. Maybe that's what I'm hearing. Maybe, yeah. I think it's possible to do it within the loop if you'd like. We could. Or let me know if that doesn't sound right. We could do it. So you are saying that perhaps instead of having these if statements inside the for loop, I could do something before then I no longer need these if statements. You could do it outside of the for loop. You could do within the for loop either way. I see. Okay. So yes, I could do that. I mean, there are many ways to do it. So I want to think that, yes. Okay. So how about, I wonder if it will complain. Okay. So mathematically speaking, I can do this left. Let me know what you think about this. So what if I set it to that and then I just multiply by a Boolean expression? I is greater than zero. So here, what I'm trying to do to say the I greater than zero, this Boolean condition will only be valid, will only say one if I'm not, I'm not at the boundary. If I'm at the boundary, then I can say your left is zero. Is that a high? Yeah, that's possible. That's possible. But then what if the value is one? Then the maximum square could still be one, even in the row and column, like the edges. Right. So I still, so yes, here, like this right and left and dag so far, they're just for reading. I still haven't inserted anything into the DP. Okay. My plan is to insert in a moment, like perhaps right now. Awesome. Okay. Okay. So if I is greater than zero and J is greater than zero, and now I can read my diagonal, diag is equal to, I'm going to copy the line four and just add a minus one. And now I want to write the DP at this moment right here. So we, just like we're brainstorming, if they're all, if they're all set, then I'll read the minimum of the three and increment by one. If they're not all set, then I'll just read the minimum. So, yes. And what would be the deciding factor for that? Whether the, yeah, what would be the deciding factor of that? So to increment by one? Yes. Basically, the array right here, the array entry should have a non-zero. Got it. If we were increment by one. And that's the first if statement in the nested for loop. That if we are at zero, then we just skip that entry. We keep it in the DP as zero. Okay. So if the code flows until this point, then here I know that we, it's a non-zero point and the top, the left and the diagonal have some numbers. And using those numbers, the top left or right, some of them could be zeros. The top left diagonal, some of them could be zeros. If they are all set, that means I should take the minimum plus one. Okay. Right. Makes sense, right? That makes sense. Awesome. So if left is greater than zero and right is greater than zero and diag is greater than zero, then I will set the entry right here, DP, I, J to the minimum of those left, right. I think I should put it in an array syntax wise. I forgot, but I can try that. Plus one. Okay. Let me think. Is there, wait, sorry, quick question. Is there a reason why we need to check the, that all the values are greater than zero if we are taking the minimum here? If we've already checked that the, it's not a zero value, do we need to actually check that? We don't need to. You are correct. Yes. So this if statement is irrelevant because if any of them is zero, then the minimum will also be a zero and the final answer will be a one, which is exactly what we need. You're right. This if statement is not needed. If anything, it might make a bug. Okay. Yeah, that's perfect. Yep. Awesome. So we still don't have the final answer. The final answer is keeping track of what was the maximum. Of course, I can stay within the same computational complexity and I can just say return the max over all of this. So return, I guess I'm going to say row wise max is equal to max row for row in dp and then I can return the max of row wise max. So row wise max in this line, basically it becomes an n numbers. Each number is the maximum in that row and then return the maximum of those. So we have the, we're invoking the max function once in this for loop and once again on the list, the final list. Is there a way to potentially get the maximum or track the maximum within your for loop? Yes, there is a way. Okay. I can do that. Awesome. Thank you. So I can start as the max, say max num as negative one in here. And every time I update, I basically read off the max. So I can say max num is equal to the max of the previous max num comma dp i j and then return that at the end. And of course there is some, you know, with every code there is ways to optimize it. Like for example, specifically here we are storing in an index of an array. We're reading again the same index. I could have stored this as a variable z or temporary variable, but I'm hoping the compiler will take care of that for me. We'll make it optimal. Definitely. Yeah. This solution looks good to me. Awesome. And I like the fact that you kept correcting me and gearing me towards the better solution. You are a good interviewer. It was you. You were always on the right track. Thank you. I hope this gives you a better understanding of what it's like to answer technical interview questions at Google. As a reminder, be sure to explain your thoughts, get clarity when possible, think through how to improve your answers, and practice ahead of time. Thanks for watching, and good luck on your interview.