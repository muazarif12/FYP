id: 1
sentence: Please note that this example is not a question you'll be asked exactly. However, it represents the type of questions we like to ask our candidates, one that allows you to state your assumptions, improve your solution, and is ultimately open -handed enough to show us how you think. If you're interested in seeing an example of solving a systems design question or learning more about our hiring process, visit the videos linked in the description below. On to the mock interview.
start: 8.04end: 29.88topic: 1score: 0.4314074911184358-----------------------------------------------------------id: 2
sentence: Just as a reminder, you won't have access to a compiler or IDE during your interview. So practice writing code with Google Docs.
start: 40.42end: 47.1topic: 1score: 0.17421100705991532-----------------------------------------------------------id: 3
sentence: A farmer wants to farm their land with the maximum area where good land is present. The land is represented as a matrix with ones and zeros, where ones mean good land and zeros mean bad land. farmer only wants to farm in a square of good land with the maximum area. Please help the farmer to find a maximum area of the land they can farm in good land.
start: 67.12end: 92.0topic: 9score: 1.0015065678187938-----------------------------------------------------------id: 4
sentence: And I held it the first, this is the second, this is the third, et cetera. Let's say we get here in this iteration. So is becoming, let's say, two and J is becoming one in this position, the row and column. So from this point, as every point that we go to, we start another double for loop, going to the right and bottom. So here I go one step to the right, there is a one, so I continue. And then I go to the bottom, there is a one I continue. And then I go to the right of it, there's a one, I continue. I wonder if that makes sense.
start: 205.92end: 239.34topic: 13score: 1.7693188953916967-----------------------------------------------------------id: 5
sentence: But as we already said, this is not optimal, but it will do the job. I think that even though this may be a brute force solution, it would be the right approach in checking the nearby values and having that inform how large the square could be.
start: 287.38end: 302.0topic: 12score: 1.3742761305805113-----------------------------------------------------------id: 6
sentence: Actually. No, I think you're on the right track, that you're checking the right below and diagonal values. But because there is a zero here, does that mean it could be a valid square? Zero is invalid, right? Yes, yes. That would be the case. So based on that, what can you infer that if you're at that one position, at that index? Yeah. index.
start: 359.82end: 385.5topic: 7score: 0.8390079349606069-----------------------------------------------------------id: 7
sentence: Yes, yes, that's correct. But you then know that the neighboring values are also ones, so there is a possibility that those could have valid squares that are greater than one. Correct, yes.
start: 392.98end: 406.7topic: 5score: 0.6409358307311874-----------------------------------------------------------id: 8
sentence: But you could potentially have, as you're saying, a recursive algorithm. How would that look then? -hmm. So the recursive algorithm, I'm trying to think out loud as I'm describing the solution. So basically, when we see a one here, we can ask, can this be part of a bigger rectangle? And recursively, how would that look like? We have to ask the neighbors how many ones they have consecutively, contiguously.
start: 419.5end: 451.96topic: 8score: 0.8587294331517522-----------------------------------------------------------id: 9
sentence: -hmm. So that could be saying that, okay, there's a one here. then we can invoke a recursive call that says, how many ones are starting at the right of me making a square? So I wish I can highlight, but let's imagine me, I'm going to bold this, I'm going to bold this, that marks the end and the beginning of a square. -hmm.
start: 452.56end: 498.74topic: 6score: 1.0163992973720695-----------------------------------------------------------id: 10
sentence: Yes. And then if, how, whichever, so whichever returns the minimum, I will take that and I'll add one to it. Trying to think if this will always be correct. So if this one said, I can do a two by two, let's say it's, it can do a two by two. I'm going to change your input by a little bit if that's okay. So which, which means this would have been one, this would have been a one. Okay. And this, the one that I'm highlighting is asking the one right of it, how big can you, can you be, your square could be. This will say, oh, I can do a two. Then it asks the bottom of it, how big of a square can you do?
start: 510.46end: 546.68topic: 2score: 0.596902481425939-----------------------------------------------------------id: 11
sentence: In this particular case going to say three. Because I can see the ones like here, this one. I think that.
start: 546.98end: 556.0topic: 8score: 0.3653423552854167-----------------------------------------------------------id: 12
sentence: I, I need to think that there, there, there has to be that we can grow the ones, you know, we have to a five or something eventually. So if the right of me can say I can do a three by three, which, you know, so maybe I can hack the numbers again, just for the sake of example, it can say I can do a three by three. actually this is still a two by two. Okay. I have to do this as a one. So the red, the red one can now do a three by three. The blue one can also do three by three. Only by three.
start: 666.4end: 693.24topic: 4score: 0.7205929664844868-----------------------------------------------------------id: 13
sentence: Which will make this be at most quadratic. We we will invoke at most times. but usually for anything that you can do with memorization, there ought to be a dynamic programming solution where you can do bottoms up. That's You want me to program the recursive memorization lazy version, or should I strive for the most efficient dynamic programming version? I'm thinking that I want to first see your thinking for the bottom the dynamic programming solution, and then we can go ahead and code it. I just want to see what your thinking would be for how bottom up would look.
start: 754.84end: 786.58topic: 11score: 1.165867805319633-----------------------------------------------------------id: 14
sentence: Sure. Okay. You kind of gave me a hint already by saying, check the diagonal, if it also can do a three by three. So in that regard, maybe I can have, I can, this is the input we're highlighting right now.
start: 786.7end: 802.34topic: 10score: 0.9334380901765822-----------------------------------------------------------id: 15
sentence: So at every, at every entry in the input, if the entry in the input is zero, then we should write zero in the dynamic programming array. If the entry is one, then we need to basically look at the surrounding positions, as you said, like the top position, just top of me, just left of me, just diagonal left of me in the dynamic programming array. we should take the minimum, but if they all agree to be like the same value, I'll just increment by one in the DP array. And the final return of this whole program is the maximum entry in the DP array.
start: 839.24end: 876.66topic: 0score: 0.4520440529180416-----------------------------------------------------------id: 16
sentence: So first I'm going to say my array is equal to an array of all zeros. I guess I I want to capture first n, which is just the length of the bin array. So it could be a 5 by 5, 10 by 10 cetera. That's n by n. So we want to make an all zero.
start: 949.88end: 966.76topic: 0score: 0.36525030999730124-----------------------------------------------------------id: 17
sentence: But your output array or your output area should be a square. Thank you for making this clarification. Okay. So then I will do this as my n times m. Okay. And now I can say something like this. Yep. So let me just make sure, yes, I'm consistent in my indexing, so to speak. That if an index ij exists in then it must also exist in bin array.
start: 992.48end: 1014.08topic: 0score: 0.07802883777874998-----------------------------------------------------------id: 18
sentence: Is it possible to handle the boundaries before you enter this scope?
start: 1119.32end: 1125.8topic: 0score: 0.03086403473102037-----------------------------------------------------------id: 19
sentence: Right. So still, so yes, here, like this right and left and dag so far, they're just for reading.
start: 1243.48end: 1249.72topic: 0score: 0.027778720886619167-----------------------------------------------------------id: 20
sentence: So if is greater than zero and J is greater than zero, and now I can read my diagonal, diag is equal to, I'm going to copy the line four and just add a minus one. And now I want to write the DP at this moment right here. So we, just like we're brainstorming, if they're all, if they're all set, then I'll read the minimum of the three and increment by one. If they're not all set, then I'll just read the minimum.
start: 1258.0end: 1289.6topic: 3score: 0.6723206603260494-----------------------------------------------------------