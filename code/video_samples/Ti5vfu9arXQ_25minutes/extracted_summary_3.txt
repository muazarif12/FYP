id: 1
sentence: Please note that this example is not a question you'll be asked exactly. However, it represents the type of questions we like to ask our candidates, one that allows you to state your assumptions, improve your solution, and is ultimately open -handed enough to show us how you think. If you're interested in seeing an example of solving a systems design question or learning more about our hiring process, visit the videos linked in the description below. On to the mock interview.
start: 8.04end: 29.88topic: 0score: 0.41364351230141183-----------------------------------------------------------id: 2
sentence: Just as a reminder, you won't have access to a compiler or IDE during your interview. So practice writing code with Google Docs.
start: 40.42end: 47.1topic: 0score: 0.15537187824836218-----------------------------------------------------------id: 3
sentence: A farmer wants to farm their land with the maximum area where good land is present. The land is represented as a matrix with ones and zeros, where ones mean good land and zeros mean bad land. farmer only wants to farm in a square of good land with the maximum area. Please help the farmer to find a maximum area of the land they can farm in good land.
start: 67.12end: 92.0topic: 7score: 0.48950557110387316-----------------------------------------------------------id: 4
sentence: I can loop over every position. And for every position, I can basically start from that moment onwards, go left and right, and count however many ones I can find in like a rectangle or a square, sorry. But that would be, if let's say the dimensions of the square is like n by n, that would be at best n to the 4, which is not ideal. And I assume by posing this question, you want to find an efficient solution. Yes.
start: 142.54end: 170.58topic: 7score: 1.163081863973309-----------------------------------------------------------id: 5
sentence: And I held it the first, this is the second, this is the third, et cetera. Let's say we get here in this iteration. So is becoming, let's say, two and J is becoming one in this position, the row and column. So from this point, as every point that we go to, we start another double for loop, going to the right and bottom. So here I go one step to the right, there is a one, so I continue. And then I go to the bottom, there is a one I continue. And then I go to the right of it, there's a one, I continue. I wonder if that makes sense.
start: 205.92end: 239.34topic: 12score: 0.8291153400358963-----------------------------------------------------------id: 6
sentence: But as we already said, this is not optimal, but it will do the job. I think that even though this may be a brute force solution, it would be the right approach in checking the nearby values and having that inform how large the square could be.
start: 287.38end: 302.0topic: 3score: 0.679375258823943-----------------------------------------------------------id: 7
sentence: Actually. No, I think you're on the right track, that you're checking the right below and diagonal values. But because there is a zero here, does that mean it could be a valid square? Zero is invalid, right? Yes, yes. That would be the case. So based on that, what can you infer that if you're at that one position, at that index? Yeah. index.
start: 359.82end: 385.5topic: 4score: 0.8390079349606069-----------------------------------------------------------id: 8
sentence: But you could potentially have, as you're saying, a recursive algorithm. How would that look then? -hmm. So the recursive algorithm, I'm trying to think out loud as I'm describing the solution. So basically, when we see a one here, we can ask, can this be part of a bigger rectangle? And recursively, how would that look like? We have to ask the neighbors how many ones they have consecutively, contiguously.
start: 419.5end: 451.96topic: 5score: 0.8587294331517522-----------------------------------------------------------id: 9
sentence: -hmm. So that could be saying that, okay, there's a one here. then we can invoke a recursive call that says, how many ones are starting at the right of me making a square? So I wish I can highlight, but let's imagine me, I'm going to bold this, I'm going to bold this, that marks the end and the beginning of a square. -hmm.
start: 452.56end: 498.74topic: 2score: 0.2478403923813581-----------------------------------------------------------id: 10
sentence: Yes. And then if, how, whichever, so whichever returns the minimum, I will take that and I'll add one to it. Trying to think if this will always be correct. So if this one said, I can do a two by two, let's say it's, it can do a two by two. I'm going to change your input by a little bit if that's okay. So which, which means this would have been one, this would have been a one. Okay. And this, the one that I'm highlighting is asking the one right of it, how big can you, can you be, your square could be. This will say, oh, I can do a two. Then it asks the bottom of it, how big of a square can you do?
start: 510.46end: 546.68topic: 1score: 0.5233044068926602-----------------------------------------------------------id: 11
sentence: In this particular case going to say three. Because I can see the ones like here, this one. I think that.
start: 546.98end: 556.0topic: 8score: 0.7728781940011079-----------------------------------------------------------id: 12
sentence: I, I need to think that there, there, there has to be that we can grow the ones, you know, we have to a five or something eventually. So if the right of me can say I can do a three by three, which, you know, so maybe I can hack the numbers again, just for the sake of example, it can say I can do a three by three. actually this is still a two by two. Okay. I have to do this as a one. So the red, the red one can now do a three by three. The blue one can also do three by three. Only by three.
start: 666.4end: 693.24topic: 9score: 1.102928744449543-----------------------------------------------------------id: 13
sentence: Which will make this be at most quadratic. We we will invoke at most times. but usually for anything that you can do with memorization, there ought to be a dynamic programming solution where you can do bottoms up. That's You want me to program the recursive memorization lazy version, or should I strive for the most efficient dynamic programming version? I'm thinking that I want to first see your thinking for the bottom the dynamic programming solution, and then we can go ahead and code it. I just want to see what your thinking would be for how bottom up would look.
start: 754.84end: 786.58topic: 10score: 1.165867805319633-----------------------------------------------------------id: 14
sentence: Sure. Okay. You kind of gave me a hint already by saying, check the diagonal, if it also can do a three by three. So in that regard, maybe I can have, I can, this is the input we're highlighting right now.
start: 786.7end: 802.34topic: 13score: 0.6951300167984306-----------------------------------------------------------id: 15
sentence: We can start with the, with the dynamic programming array with this, that has the same exact size, but it's initialized to zero everywhere. Then at any moment that I want to compute an entry, I want to populate an entry in this DP matrix that at all zeros. I'll be looking at the same position of the input and also the surrounding positions of the input and potentially the surrounding positions of the dynamic programming array, the DP array, and populate it incrementally as such. And so your DP array would contain what values exactly?
start: 802.34end: 838.1topic: 6score: 0.9411619855935943-----------------------------------------------------------id: 16
sentence: So at every, at every entry in the input, if the entry in the input is zero, then we should write zero in the dynamic programming array. If the entry is one, then we need to basically look at the surrounding positions, as you said, like the top position, just top of me, just left of me, just diagonal left of me in the dynamic programming array. we should take the minimum, but if they all agree to be like the same value, I'll just increment by one in the DP array. And the final return of this whole program is the maximum entry in the DP array.
start: 839.24end: 876.66topic: 0score: 0.22091589935238312-----------------------------------------------------------id: 17
sentence: So programming Python into a document. So maybe I can choose as a font I can say def largest square and it takes input as a binary array. I'm going to say bin array.
start: 909.5end: 925.1topic: 0score: 0.10996018609208874-----------------------------------------------------------id: 18
sentence: First, if the entry had a zero. If bin array of i is zero, then the DP will have a zero in it.
start: 1041.24end: 1053.68topic: 11score: 0.8805072532740094-----------------------------------------------------------id: 19
sentence: Is it possible to handle the boundaries before you enter this scope?
start: 1119.32end: 1125.8topic: 14score: 0.48665985729342237-----------------------------------------------------------id: 20
sentence: But then what if the value is one? Then the maximum square could still be one, even in the row and column, like the edges.
start: 1234.32end: 1242.64topic: 12score: 1.1160813652033212-----------------------------------------------------------id: 21
sentence: So if is greater than zero and J is greater than zero, and now I can read my diagonal, diag is equal to, I'm going to copy the line four and just add a minus one. And now I want to write the DP at this moment right here. So we, just like we're brainstorming, if they're all, if they're all set, then I'll read the minimum of the three and increment by one. If they're not all set, then I'll just read the minimum.
start: 1258.0end: 1289.6topic: 2score: 0.6723206603260494-----------------------------------------------------------id: 22
sentence: Okay. So if the code flows until this point, then here I know that it's a non -zero point and the top, the left and the diagonal have some numbers. And using those numbers, the top left or right, some of them could be zeros. The top left diagonal, some of them could be zeros. If they are all set, that means I should take the minimum plus one. Okay. Right. Makes sense, right? That makes sense. Awesome.
start: 1317.08end: 1344.7topic: 6score: 0.41671853802026865-----------------------------------------------------------id: 23
sentence: So we still don't have the final answer. The final answer is keeping track of what was the maximum. Of course, I can stay within the same computational complexity I can just say return the max over all of this. So return, I guess I'm going to say row max is equal to max row for row dp then I can return the max of row wise max. So row max in this line, basically it becomes an numbers. Each number is the maximum in that row then return the maximum of those. So we the, we're invoking the max function once in this for loop and once again on the list, the final list. Is there a way to potentially get the maximum or track the maximum within your for loop?
start: 1409.12end: 1466.74topic: 13score: 2.035537991664856-----------------------------------------------------------